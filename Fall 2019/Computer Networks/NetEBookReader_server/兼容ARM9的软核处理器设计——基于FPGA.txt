第一章 数字电路设计模型
1.1 数字电路的最简抽象模型
任何复杂的数字电路都可以抽象成带有输入输出的黑箱模块或其组合。
1.2 组合逻辑
组合逻辑电路的输入变化都会立即导致输出重新计算，但输出的变化(如有)会有延迟。
1.3 时序逻辑
时序逻辑最基本的器件是寄存器。
D寄存器在时钟上升沿赋值为输入信号(有延迟)，在其它时刻保持现有状态。
1.4 同步电路
异步电路中寄存器的时钟输入来自不同的时钟源。
异步电路中采用同一时钟源的电路可以作为同一种类型来分析，而它们之间的连接必须单独考虑。
1.5 同步电路的时序路径
同步电路的时序路径分为四类：
外部输入端口输入到寄存器；寄存器输出端口输入到其它寄存器(包括自身)输入端口；
寄存器输出到外部输出端口；输入端口通过组合逻辑直接到输出端口。
寄存器到寄存器之间组合逻辑消耗的时间不能超过一个时钟周期。
通常是最长的组合逻辑串决定时钟周期/频率。
1.6 RTL描述
一个数字电路可以采用RTL（寄存器传输级）设计描述：
第一步，确定需要用到多少寄存器；第二步，对每一个寄存器的输入端口进行描述；
第三步，从时钟频率、组合逻辑等方面确保寄存器之间正常连接。
一个寄存器最重要的属性就是其输入端口连接的组合逻辑串。
该输入描述可能是该电路中所有外部输入端口和所有寄存器输出端口的函数。
只要给出了所有寄存器的输入描述，就确定了电路所有的组合逻辑。
1.7 综合生成电路
设计数字电路时不必在硬件程序中给出确定的实现方案，我们可以用行为级或更高抽象级别的描述，而综合软件会将其综合生成我们需要的电路。

第二章 Verilog RTL编程
2.1 Verilog语言
assign语句用于描述组合逻辑串。
always @ (...)的含义是，当且仅当"..."发生时重新计算语句内的表达式。
<=符号专用于寄存器描述，它的含义是符号右边的值在时钟上升沿结束后存入左边，同一个always语句下的所有"<="语句是并行的。
2.2 Verilog设计的基本单元
always @ (...)语句一般用于描述寄存器的行为，可以在该语句中描述寄存器本身和它专属的一段组合逻辑。
assign语句用于描述简单的组合逻辑，但要求在一个语句内完成描述。
always_comb用于描述复杂的组合逻辑，系统将自动在接下来的语句中寻找敏感信号（等效于always @ (*) ）。
function ... endfunction语句用于描述多次调用的组合逻辑，该语句也是可综合的。
2.3 RTL设计原则
任何编程语言都实现对信息的处理。在进行RTL描述时信息以寄存器的形式存在，就像C语言中的变量。
设计完电路后需要检验寄存器之间的相互关系是否符合预期，这通过仿真来实现。
2.4 RTL设计要点
作者建议，描述设计时，寄存器需要与实体明确地一一对应，组合逻辑则不必完全描述出具体构造，它往往附属于寄存器。
综合软件会标出电路中最长的路径（关键路径），如果关键路径超标，则需要调整描述风格，让综合器使用较少的逻辑串来描述关键路径。
2.5 RTL设计实例：UART串口通信

第三章 仿真
3.1 仿真的意义
仿真就是对设计的试用过程：给予RTL设计一定的激励，观察响应是否正确。
RTL设计的完整流程要求完成设计后立即检验正确性，这样才能验证当前设计能否符合对应的需求，如果可以，则在下次碰到相同需求的时候可以照搬这种设计套路，从而提高熟练度；
而不是仅仅写完RTL代码，然后采取哪里有问题修复哪里的策略。
3.2 testbench文件
testbench文件是这样一类Verilog程序，它给待测试的Verilog程序送入指定的信号，接收其输出信号(并进行一定的测试)。
一个testbench文件是封闭的，只为一个特定的RTL文件服务，一般无外部输入输出端口。
3.3 Modelsim仿真
仿真软件默认情况下会认为信号传递没有延时。我们可以手动为每一个寄存器赋值语句给予延时，但不超过一个时钟周期。可以用`define语句定义常量。
3.4 仿真实例：UART串口仿真
task语句和function类似，但不必返回数据。可以在仿真文件中用task语句表示频繁调用的代码。
可以调用系统函数，如$end表示结束仿真，$display表示输出调试信息。

第四章 FPGA开发板原型验证
4.1 FPGA内部结构
FPGA与CPU的异同：都采用二进制配置文件来控制执行效果；
CPU芯片只有一个“大脑”，包干所有“活计”，但也只能一件接一件地做事情；
FPGA则依靠一个虚拟的“团队”，并发执行效率可能高于CPU。
CPU芯片的二进制配置文件由C语言编译而成，FPGA则由Verilog RTL语言编译而成。
FPGA称为“可编程”芯片，编译器将Verilog编译成二进制编程文件下载到FPGA中，使FPGA被“编程”为Verilog RTL功能的芯片。
Xilinx Spartan-3系列的芯片内部构造：
四周是IOB(Input/Output Block)，其引脚可以由用户配置成输入、输出或同时可输入输出的，电压也可由用户配置。
特殊功能部件有DCM（生成时钟信号）、block RAM（专门用于RAM的实现）、Multiplier（专门用于乘法运算）。
最基本的部件是CLB(Configurable Logic Block)。一个CLB内部是4个Slice，分为两个SliceL和两个SliceM。
每个Slice含有两个寄存器，用于实现RTL编程中的寄存器单元，其他部分（LUT、进位、MUX、运算逻辑等）实现组合逻辑。
实现组合逻辑的核心是LUT4，它有4个输入端口、1个输出端口，每种输入对应的输出可任意设定，是根据用户配置来设定的。用于实现各种各样复杂的组合逻辑。一个LUT4可以描述任何四输入一输出的组合逻辑。
SliceL和SliceM的区别是内部存放这16个输出值的载体不同，SliceL是一次写入、使用时不可更改，配置后只能作为组合逻辑；SliceM使用寄存器，所以它可以充当RAM，也可以用于移位寄存器。
4.2 FPGA开发板
FPGA开发板是以FPGA为核心、围绕其放置了各种外设的电路板。用户的设计可以通过和外设连接的接口，驱动外设工作或获取外设数据。
FPGA开发板上的接口一般分为以下几类：
(1)简单电平(switch)/脉冲输入(button，按下时产生一个脉冲信号)。
(2)简单信号显示。包括LED、七段数码管、LED显示屏。
(3)时钟信号输入。可以直接利用焊接在开发板上的晶振，也可以接入外部时钟。
(4)存储单元。包括板上焊接的Flash、SRAM、SDRAM和有些开发板配备的SD卡槽等。
(5)专用输入输出接口。如UART串口、VGA接口、USB接口。
(6)扩展接口。用于在FPGA开发板上增加专用于某种应用的子板。
4.3 FPGA设计开发流程
第一步，评估FPGA的片外资源和片内资源。
片外资源指FPGA引脚连接的资源，它是通过明确FPGA各个引脚具有何种功能确定的；
片内资源指FPGA内部结构中的资源，包括DCM(Digital Clock Manager)、Multiplier、Block RAM，有的可以通过Verilog RTL描述自动调用，有的则必须通过配置IP的形式来进行。
第二步，围绕这些资源进行Verilog RTL编程。
第三步，使用仿真工具对设计进行调试。
片外资源是在testbench文件中“虚拟”出来的，片内资源如通过Verilog RTL描述的方式调用，则无需改动，如通过配置IP的方式，则需要调用FPGA生产商提供的仿真模型（当然也能手动编写仿真模型）。
第四步，FPGA下载执行。
这一步又分为四个子步骤：
综合优化。将Verilog RTL描述中抽象的组合逻辑描述具体化成门级（基本逻辑单元组成的逻辑连接关系图）。
翻译(translate)。将由基本逻辑单元联系而成的网表映射成FPGA底层元件的逻辑结构，如把以与门、或门、非门连接的逻辑变成以LUT4为主体的描述。
翻译过程可以由用户的约束指定方向，比如要求面积小则会把多个逻辑门融合到尽量少的LUT4上，要求时间短则会优化关键路径使其经过尽量少的LUT4。
映射(map)。把由FPGA底层元件连接的网表对应到该FPGA内部的CLB和IOB上。但仍然不是一一对应的映射，只是确定某些CLB分配给某些种类逻辑。
布线(place&route)。根据上一步的布局对具体CLB和IOB进行可编程连线，形成真正能够下载到FPGA的二进制bit文件。布局布线工具会进行优化，避免一个Slice和其它太多Slice连接在一起形成拥塞。
4.4 FPGA设计内部单元
在进行RTL编程时，如果了解FPGA的构造，针对其结构进行编程，则FPGA的综合器可以生成非常高效的网表，在FPGA中执行的效率也会很高。
FPGA内部有一些基本单元(primitive)和宏单元(macro)，在FPGA供应商提供的帮助文档中会列出。如果想优化FPGA设计，则可以在设计中直接例化，也可以通过行为相符的HDL描述来调用它。
以Xilinx Spartan-3E为例：
(1)算术功能单元。可例化调用，综合器也会直接把HDL中的整数乘法用这些单元级联实现。
(2)时钟单元。一般自动调用即可，也可手动干预。
(3)输入输出端口单元。一般情况下FPGA顶层输入输出引脚会自动根据情况应用这些单元。
(4)RAM/ROM存储单元。欲使综合工具将相关语句例化为Block RAM，描述风格必须和Block RAM的行为一致，具体参看综合器帮助文档。而在HDL中描述的大型ROM可以采用IP配置向导生成以Block RAM为基础的ROM。
(5)寄存器和锁存器单元。几乎总是自动调用，但了解这些寄存器单元有助于我们写出风格更加相符的HDL描述。
(6)移位寄存器单元。不带复位信号，所以我们在RTL描述中描述移位寄存器时一定不要出现复位信号。
(7)Slice/CLB。
我们可以根据这些基本单元的特性，有意识地写出风格相符的RTL描述，引导综合工具识别为其认可的基本单元的连接。
4.5/4.6 UART设计在Xilinx FPGA的下载执行
首先确定使用到的外部资源：时钟、复位按键、串口通信端口。考虑到FPGA开发板自带时钟和我们需要的时钟频率不符，还需要使用片内资源PLL，通过配置IP的方式来进行。
接下来设计实验，并设计出对应的顶层文件。
本例中一种可行的实验设计是，串口接收到rx_vld/rx_data以后，直接引入tx_vld/tx_data上；
也可以新增读缓冲和发送按键，用一个1KB的Block RAM作为缓冲，将rx读到的数据按顺序写入其中，在按下发送按键后从该RAM的0地址取数据并通过tx端口发送出去。
最后设计约束文件（可以通过制造商提供的软件进行，也可手动编写），指定你设计的模块的端口和FPGA引脚的对应关系。（如使用FPGA制造商提供的现成约束文件则无此必要）
完成以后，经过综合、翻译、映射、布线（这三步统称为实现，implementation）、生成码流的过程，即可下载到FPGA执行。
这些过程每一步都有报告供设计者查阅，如综合报告中可以检查自己的设计是否被综合成了理想的底层元件(e.g. 上面第二种实验设计中的读缓冲是否真正综合成了block RAM)。
使用串口通信线将FPGA开发板和PC等其它设备连接，然后通过这些设备上的对应工具（如PC上的“迷你终端”软件）进行测试。

第五章 ARM9微处理器编程模型
5.1 ARM公司历史
5.2 ARM的处理器架构
5.3 微处理器基本模型
微处理器只需会简单的基本操作，而简单操作组合形成的一整套动作的意义不是微处理器的责任范围，而是由计算机程序决定。
微处理器向指令池发出取指令需求、得到指令、进行执行、然后接着取下一条，如果没有中断则会一直重复这个过程。
“中断”本身不提供指令给处理器执行，而是一种提醒处理器暂时中断当前指令执行流程、切换到某段固定指令段的机制，且CPU有权屏蔽。
RISC指令对CISC指令集中的很多指令作了分解，如将mov (%eax), (%ecx)分解为两条指令：先将(%eax)中的数据读入CPU内部的暂存寄存器，再将暂存寄存器的内容写入(%ecx)。
有了内部的暂存寄存器组，RISC指令的操作可以分解为两个处理过程：(1)数据池与寄存器组数据交换、(2)取寄存器组的数据进行处理后写回寄存器组。处理数据池的数据需要循环进行1-2-1的流程。
5.4 ARMv4架构模式
ARMv4架构微处理器有7种运行模式：
用户模式USR，限制访问；系统模式SYS，用于运行特权级操作系统；特权模式SVC，仅供操作系统使用的一种保护模式；
快速中断模式FIQ，用于快速高优先级中断处理；外部中断模式IRQ，用于一般的中断处理；
数据访问异常模式ABT，取指或取数据发生异常时进入；未定义指令异常模式UND，执行的指令未定义时进入。
处理器启动时处于SVC，用于对各种资源进行初始化，然后进入USR或SYS。
USR模式对资源的访问是受限的，而且它无权修改CPU的模式，只有借助软中断指令进入SVC来修改。
SYS和SVC一样是访问不受限制的。
如果处在上述三种模式时发生了IRQ中断或FIQ中断而且没有被屏蔽，则系统会进入相应的中断模式，中断处理完毕后会自动恢复到先前的模式。
如果出现上述两种异常，则进入相应的异常模式，进行异常处理，然后恢复到先前的模式。（一般在进入异常模式后、异常处理前，OS会找到发生异常的相关指令重新执行一遍，确保不是误报。）
5.5 ARMv4架构内部寄存器
5.6 ARMv4架构的异常中断
ARMv4架构处理器正常情况下工作在USR或SYS模式，在出现异常中断时进入相应的模式，并修改PC指向相应的值。
7种异常中断：复位，进入SVC；FIQ快速中断，进入FIQ；IRQ中断，进入IRQ；数据处理异常，进入ABT；取指异常，进入ABT；未定义指令异常，进入UND；SWI软件中断异常，进入SVC。
5.7/5.8 ARMv4架构的指令集和中断

第六章 兼容ARM9微处理器的Verilog RTL设计
6.1 确定RTL设计的输入输出端口
显而易见进行RTL设计首先需要根据功能确定输入输出端口。兼容ARM9微处理器的端口连接到指令池和数据池，按一定法则获取指令，然后按照指令操控存储在数据池的数据。
指令池和数据池的端口也是按需设计。微处理器发出读指令使能和指令地址后，在下一周期得到指令；指令池模型需要产生取指异常中断，所以需要在给出指令的同时指出本次取指令操作是否正常。故输入信号有时钟、读使能、读地址，输出信号有指令、取指异常标志。
数据池则需要读数据、写数据，而且还分为字操作、半字操作、字节操作，所有这些操作行为都通过同一套总线发送给数据池。为此，输入端口有：时钟、使能、写使能、字节使能、地址、写数据，输出端口有：数据输出、取数据异常标志。
考虑到很多cache并不能如理想状况那样在一个时钟周期内释放读写结果，增加一个端口cpu_en以使处理器能够暂停，等待cache读写。
CPU需要实现ARMv4架构的7种中断和20条指令，故在之前的基础上再增加3个中断源输入（reset、IRQ、FIQ）。至此我们就完成了输入输出端口的设计。
6.2 经典三级流水线架构
在进行微处理器的RTL设计之前，我们必须确定整个微处理器的流水线架构。采用流水线架构是因为，指令从取出到执行完毕是一个相对复杂的过程，为了不让一条指令占用太多CPU时间，我们把它分成3或5步执行。
一般的三级流水线架构：取指、译码、执行。但对于数据池相关指令，把数据池数据载入寄存器无法在一周期内完成，因为数据池也需要一个时钟周期才能释放读数据结果。这样一来，这类LDR指令的执行必须花费5周期：取指、译码、算地址、访存、回写。
我们可以看见一条LDR指令可以使三级流水线停顿两拍。不幸的是，LDR指令一般是相当常见的，为了防止其严重降低效率，我们从结构上改变流水线，使其影响消失。
6.3 经典五级流水线架构
五级流水线解决了LDR指令延时的问题，甚至可以认为，正是因为LDR需要5时钟周期，人们才修改流水线为五级的。一般的五级流水线架构：取指、译码、算地址、访存、回写。
但在两条相关（前一条指令的输出是后一条指令的输入）的MOV指令相连的时候，仍然必须在五级流水线的基础上延时2时钟周期（否则后一条指令将得到“过时”的结果）。这个问题可以修正，我们可以把前一条指令的回写结果提前使用，即后一条指令进入执行阶段时直接取出在流水线上尚未回写的上一条指令的结果（而非寄存器内过时的结果）。但当一条LDR连接一条相关的MOV时，该方法无效（因为需要使用的数据尚未取出），仍然必须延时2拍。
6.4 三级流水线改进架构
为了给数据池访问指令留出足够的时间，同时又不让寄存器处理类指令出现不必要的延时，可以设计出这样的一种三级流水线：
寄存器类指令和数据池的写指令同经典三级流水线，数据池读指令LDR延迟一拍变为四级――取指、译码、执行、回写。这里“执行”同时完成算地址和发出访存信号两个操作。
如果遇到正处于第三级的读指令的输出和处于第二级的指令的输入相等的时候，必须将后者暂缓执行，并在第三级插入一条空指令。
6.5 适用于兼容ARM9微处理器的三级架构
接下来我们考察具体如何用这套流水线实现ARM9指令。ARM9指令分为两大类：数据池读写指令、寄存器处理指令。
数据池读写指令本身不涉及复杂的数据操作，相对复杂的是生成读写地址，读写地址一般是Rn加第二操作数生成，而最复杂的第二操作数是LDR0和LDR1，是通过Rm或立即数移位生成的。所以，数据池读写指令的复杂数据公式为：Rm>>num + Rn。
寄存器处理指令中比较复杂的是乘法MULT和长乘法MULTL，它们处理数据的公式是Rm * Rs + Rn；此外还有DP0、DP1、DP2，它们的公式是Rm>>Rs + Rn 或 Rm>>num + Rn。
由此可见ARM指令集最多需要两步操作，第一步是由Rm和Rs进行移位或乘法操作得到第二操作数，第二步是由第二操作数和Rn进行加法为主的运算操作。由于乘法MULT和长乘法MULTL指令的存在，乘法运算无法避免，所以必须使用乘法器。那么我们需要考虑是否可以通过乘法器实现移位运算。
DP指令有四种移位方式：逻辑左移、逻辑右移、算术右移、循环右移。乘法器显然能实现逻辑左移；对逻辑右移，Rn和1<<num相乘的64位结果中，我们发现高32位就等于Rn<<(32-num)，问题解决；对算术右移，如果符号位为1则将Rm取反再乘法再取反；对循环右移，将64位乘法结果的高32位和低32位进行或操作即得。
这样一来，每条指令都可以用一个乘法器串联一个加法器来实现。那么流水线的第三级就会是一个乘法器串联一个加法器，决定设计频率的关键路径就是这两者的耗时之和。
再考虑能否打破串联，以减小关键路径。我们发现，可以在第二级译码的时候顺便进行乘法运算得到第二操作数。至于译码操作本身，因为ARM9指令集非常简单，只需要21条assign code_is_xxx = ...的语句生成非常简单的组合逻辑即可完成，不必设计专门的译码单元。这样就在不增加流水线级数的前提下打破了串联，缩减了关键路径，从而兼容ARM9处理器可以运行在更高频率上。
虽然如此，这一设计会带来数据冲突问题，因为乘法操作会从寄存器组中读取Rm和Rs，如果第二级乘法正在读取Rm和Rs，同时第三级的指令又在改写要读取的寄存器，就会造成数据冲突，与之前讲到的LDR的冲突一样。
6.6 影响流水线架构执行的四种状况
为了让每一条指令都可以使用这套流水线实现，需要考虑三级流水线之间所有可能的互动情况。
首先考察三级乘加结构的关键信号，因为有暂停流水线的需求，所以给每一级增加一个使能信号。这样一来，需要考虑的关键信号有rom_en、rom_addr、code、code_flag、cmd(第二级指令传递到第三级后的新名称)、cmd_flag、"Rm"、"Rs"、sec_operand(第二操作数)、Rn、to_vld、to_num(结果写入哪个寄存器及其使能信号)、cha_vld、cha_num(回写信号)、go_vld、go_num(回写信号在第四级的新名称)。
接下来逐个和逐对考察ARM9指令集的指令，对于所有可能影响流水线执行的指令或指令序列加以特殊处理。对跳转指令BX，其判断条件是to_vld == 1 && to_num == 4'hf，需要确保跳转指令后的其他指令不被执行，故在跳转指令执行到第三级时需要将rom_en赋值为0以使得处理器不再取其后的指令，然后在下一时钟周期将cmd_flag和code_flag置为0以阻止已被取出的后续指令的执行，并恢复rom_en为1（这一时刻PC已被赋给新值）。还有另一种跳转的方式是LDR PC, [R0]，在指令执行到第三级时也令rom_en = 0，下一周期（指令执行到第四级）也令code_flag = cmd_flag = 0，但由于此时PC还没有完成赋值，我们仍然需要再令rom_en = 0，并在下一时刻仍然令code_flag = cmd_flag = 0，判断条件是go_vld == 1 && go_num == 4'hf。
当出现LDR R1, [R0]和MOV R2, R1这种前后两条指令的输入输出相互关联的情况，即数据冲突时，必须在它们中间插入一个空指令。判断条件是Rm和Rs对应的寄存器和to_vld、cha_vld、go_vld对应的寄存器中有相同，编程时需要综合多种情况，用'|'连接（例如code_rm_vld(当前指令使用的"Rm"是一个寄存器) & cha_vld & (cha_num == code_rm_num)），处理方法是在数据冲突的前一条指令执行到T3时置位rom_en = 0使得下一时刻流水线第二级的内容仍然是数据冲突的后一条指令，然后在下一时刻让cmd_flag = 0使得进入第三级的后一指令不执行（执行的是留在第二级的后一指令）。
多周期指令。简单起见先考虑两个周期的指令，以SWP为例，若SWP位于第三级，则首先让流水线等待（声明一个组合逻辑hold_en表示多周期指令正在执行，定义见后），让rom_en = 0，执行完第一个周期的工作之后让cmd从SWP变成SWPX（SWP的另外一种格式，表示只进行SWP的写操作部分，是单周期），并且恢复rom_en且解除流水线的等待。对于多个周期的指令LDM，这个指令的[15:0]中有多少位为1则表示还需要进行多少个周期的读写操作，最后再进行单周期的地址回写，仿照SWP的处理方式，我们置位rom_en = 0，同时依次对[15:0]中为1的那些位对应的寄存器进行读写操作并让相应的位变为0，到cmd[15:0]变为全0之后就恢复rom_en，解除hold_en，并完成地址回写。判断条件hold_en = cmd_ok & (cmd_is_SWP | cmd_is_MULTL | (cmd_is_LDM & (cmd_sum_m（cmd[15:0]的和） != 5'b0)))。
中断。

第七章 在兼容ARM9处理器内核上运行Hello World程序
7.1 基于FPGA的SoC设计流程
在进行具体的SoC设计时，处理器的指令池、数据池、中断必须具体化到设计实体中：
指令池一般具体化为ROM，数据池则在实现不同功能时例化为ROM、RAM或者寄存器（寄存器通常连接外设，对外设定义行为规则或交换数据）中的不同种类，IRQ和FIQ中断的功能也应该予以定义。
这样一来，设计过程就从以寄存器为最小单元的逻辑设计转变为以微处理器为核心、带ROM、RAM和寄存器的独立嵌入式系统为中心的逻辑设计；
输入端口作用于该嵌入式系统的两个途径是：输入端口连接到微处理器的中断端口，或者连接到寄存器中改变某个寄存器的值；
输出端口连接某个寄存器，嵌入式系统写入这个寄存器时输出改变。
接下来在进行嵌入式软件的编写之前，必须将ROM、RAM、寄存器分配到具体的地址，这是嵌入式系统运行的内环境；
ROM和RAM直接分配连续的地址范围即可，但ROM和RAM的不能重叠；
寄存器的地址是离散的，可以直接选用某种成熟的单片机外设寄存器设定情况，也可以自定义访问规则并写在.h/.c文件中。
在内环境定义完毕后，参照这个内环境进行SoC硬件和嵌入式软件的设计工作；
工作结束后，嵌入式软件生成一段.bin代码，SoC硬件将这段.bin代码置入ROM，即完成了一个全面的SoC设计。
欲完成输出"Hello World"的SoC设计，首先容易想出，除了实现嵌入式系统之外，还需给UART模块配置专用寄存器，以实现对串口收发数据的操作；
第一步是定义兼容ARM9内核的工作内环境，第二步是定义上述的专用寄存器（包括对应的行为规则）。
7.2 使用RealView MDK编译Hello World程序
在嵌入式软件IDE――RealView MDK-ARM中建立工程，依次定义好单片机具体型号、编译设置（如不生成thumb指令）、其它命令（如从生成的.axf文件中解析出.bin），开始开发。
示例工程中的文件用途：startup.s，完成配置单片机和设定栈，初始化各个模式下的状态；Hello.c，主函数所在文件；Retarget.c，重定位printf依赖的一些函数使其定位到Serial.c的相关函数中；Serial.c，描述串口底层函数。
7.3 仿真输出Hello World
μVision中编译产生的.bin文件的内容就是一行一行的ARM指令。我们可以用Verilog写一个testbench文件，直接用$fopen和$fread函数打开这个.bin文件，将其内容读入到ROM（指令池）中，并解析兼容ARM内核，最后通过$write输出Hello World字符。
可以通过在波形中添加ROM相关的信号（rom_en/rom_addr[31:0]/rom_data[31:0])来观察指令的提取情况，添加RAM相关的信号（ram_cen/ram_wen/ram_flag[3:0]/ram_addr[31:0]/ram_wdata[31:0]/ram_rdata[31:0]）来观察数据池的读写情况，也可添加r0~re来观察微处理器内部寄存器组的变化情况。
7.4 建立Hello World的FPGA设计工程
兼容ARM9处理器可以与嵌入式编译软件μVision完美结合：只要从μVision编译出.bin文件，转换成.coe，读入ROM中，即可让CPU按嵌入式程序的指令工作。
仿照第一节中所说的流程，不难画出以ARM9内核为核心的SoC FPGA的设计框图，具体包含兼容ARM9内核、UART、ROM和RAM（对应指令池数据池）、寄存器。采取自顶向下的方式，来完成一个完整的设计。
ROM：生成IP，读入hello.bin。IP的设置根据实际需要设置为双口ROM，各个端口的宽度、读写方式等也根据CPU总线情况而定，深度则根据μVision中设定的ROM大小除以宽度计算而来，根据需要为每个端口都配备enable引脚，并指定init file（因为只接受.coe格式的init file，所以需要在仿真过程中通过$fopen、$fread、$fdisplay将.bin转换成.coe）。
RAM：生成IP。大小由μVision中的设定指定，宽度为总线宽度32位，因为还涉及到字节使能ram_flag[3:0]，故勾选byte write enable。
寄存器：已经在μVision中设定完成。板上实现是功能模拟（而不一定必须分配到指定的物理地址），将寄存器对应的地址（ram_addr == 32'he000_0004）写在其涉及的功能语句中即可（如tx_vld <= ram_cen & ram_wen & (ram_addr == 32'he000_0004)）。

第八章 兼容ARM9处理器内核性能测试 Dhrystone Benchmark
8.1 Dhrystone 2.1简介
Dhrystone主要测试微处理器的整数性能，嵌入式处理器由于面积和低功耗限制会将其性能向整数和逻辑运算倾斜，所以用Dhrystone测试嵌入式处理器更能体现其测量价值。ARM公司对其旗下的处理器内核一般采用Dhrystone 2.1版本进行测试。
μVision的DHRY例程包含7个源码文件：startup.s、retarget.c、serial.c、time.c、dhry.h、dhry_1.c、dhry_2.c。前三个文件同第7章的3个文件，第7章在使用之前修改了这3个文件，我们将修改过的文件拷贝过来覆盖原来的3个文件。time.c是一个定时器，用于计算处理器完成Dhrystone的耗时；dhry_1.c和dhry_2.c是Dhrystone测试的主程序。
值得一提的是，Dhrystone是以测试经过的时钟周期数作为测试时间的，所以受试处理器1s跑完Dhrystone Benchmark的次数还需要除以时钟频率(MHz)才能得到最终的性能指标Dhrystone MIPS。另外，运行次数需要足够大。
8.2 移植Dhrystone 2.1进行编译
首先，我们根据实际情况对于在FPGA运行上不必要的代码进行删改。然后，为了避免大量修改仿真文件，我们将该工程的器件修改为之前的LPC2100系列，但是LPC2101的ROM、RAM太小以至于无法编译，尝试发现最低需要设为LPC2104。最后参照上一章的操作将编译生成的.axf转换成.bin。
当然了，为了获得尽可能高的执行效率，我们需要根据ARM公司提供的指导Dhrystone Benchmark编译的文档，设置合适的编译参数，如-O3 -Otime --no_inline --no_multifile。
8.3 仿真运行Dhrystone Benchmark
我们直接拷贝上一章的testbench文件进行修改，内容包括修改时钟频率为1MHz、按LPC2104设定扩大ROM/RAM大小、定时发送IRQ中断（因为定时中断是time.c中用到的计时方式）。
接下来还需要将输入仿真次数的语句改为直接赋值，因为仿真环境无法输入数据。再仿照上一章的方法启动仿真，但遇系统提示Out of heap memory，故将startup.s中定义的Heap Size扩大，再次运行略多于3s的仿真时间（测试需3s，还需若干毫秒打印完整的测试信息），得到测试结果。
8.4 在线可编程的FPGA SoC设计工程
按上一章的设计，每修改一次ROM的内容就必须重新综合一次，时间消耗巨大。我们可以设法通过UART将.bin文件发送到FPGA开发板的ROM中，解决这个问题。
这样就必须使得ROM可以设置为可写状态，从而这个FPGA SoC设计工程有两个状态：工作状态和编程状态（处理器内核不工作，ROM可写）。所以我们将SW[0]连接到cpu_en和ROM的wea(Port A Write Enable)信号。并且需要更改设计，使得可以每从串口接收4字节数据就送入ROM一次。最后还需要按需添加定时发送中断的逻辑。
还需注意，处理器切换到工作态时必须手动复位一次，以使得PC从0x0再次开始工作。
这样一来，FPGA就可以在线编程，从而可以认为是完整地模拟了单片机开发板的功能。
8.5 Dhrystone Benchmark在开发板中运行
在烧录二进制码流文件后，开发板会按照ROM中设定好的初始内容运行。为了在线修改ROM，我们可以将上节指定的SW[0]扳到输出为1'b0的一端，然后通过串口调试助手发送.bin文件到开发板，发送完毕后将SW[0]置为1并按下复位按钮，开发板即按照新写入ROM的内容运行。
在运行Dhrystone Benchmark时，开发板会通过串口询问运行次数，我们通过串口发送运行次数到开发板（注意发送格式），即可进行Dhrystone测试。

第九章 uClinux仿真――结合SkyEye启动不带MMU的操作系统
9.1 ARM7TDMI-S处理器内核
首先了解在单片机和低端手机市场相当活跃的ARM7系列。ARM7系列微处理器包括ARM7TDMI、ARM7TDMI-S等四种类型，ARM7TDMI的使用最为广泛，其名称的含义是：T代表thumb指令集（thumb指令是16位的，所有thumb指令都有对应的32位ARM指令形式，所以使用thumb指令集有助于节省ROM存储空间），D表示支持片上debug（通过JTAG并口），M表示内嵌硬件乘法器（但是为了降低面积和功耗，只是32×8的乘法器），I表示嵌入式ICE-RT逻辑（in circuit emulator real time，使处理器支持片上断点和调试点）。ARM7TDMI-S则是ARM7TDMI的可综合的软核形式。
ARM7TDMI-S采用三级流水线：取指、译码、执行。它采用冯诺依曼结构，指令池和数据池通过同一个memory interface访问，这套memory interface与ARM公司推出的AMBA总线高度相似。它有4种传输类型：内部周期（通常情况下不传播数据时）、非连续传送周期（传送单个数据）、连续传送周期（用于LDM等需连续传输多个数据时）、协处理器寄存器传送周期（处理协处理器指令时）。
ARM7TDMI-S作为可综合的软核，也拥有我们使用module描述时的input和output端口。它拥有时钟输入、中断接口、大小端配置接口、总线控制信号、调试接口、ICE-RT访问、memory interface、协处理器接口等一系列端口，可以查询用户手册来获取每一个端口的详细信息。
ARM7TDMI-S内部主要分为三个部分：Embedded ICE-RT macrocell、Embedded ICE-RT TAP controller、CPU内核。前两个部分服务于ICE-RT，接收用户的调试指令并转而对CPU内核发出相应的指令，包括暂缓CPU内核的执行和对memory interface发出读写指令。CPU内核与本书的兼容内核功能大致相同，也是不断取出指令译码执行，但可以支持连接协处理器。值得一提的是，CPU内核不能直接参与调试，其支持的调试操作只有暂停执行，类似于对本书的兼容内核的cpu_en置0。
ARM7TDMI-S的CPU内核符合经典三级流水线模型，从memory interface中读取指令，通过instruction pipeline进行指令译码并将译码结果通过传给register bank，由register bank运算得到第二操作数，第二操作数和Rn一起送入ALU即可进行地址或数据运算，然后交由address register读写内存或传给register bank写回寄存器。遇乘法指令时由32×8乘法器和barrel shifter共同完成运算。ARM9TDMI和ARM7TDMI类似，在ALU和regbank之间有两个可选部件barrel shifter和multiplier，它们的关键路径是MUL+ALU或shifter+ALU中的一条。因为它们的关键路径是两个模块的叠加，所以它们在FPGA上运行的时钟频率不能达到很高，约25MHz。
通过本节对ARM7TDMI-S内核的分析，可以看出这些处理器内核并不是非常神秘的“天外来客”，它也是具有输入输出端口的RTL描述，也是在对处理器内核完成描述后添加各种调试功能接口。只要在设计上下足功夫，读者也能设计出非常优秀的处理器内核。
9.2 以ARM7TDMI为核心的单片机
处理器内核需要配以外设才可以完整地实现其功能，就如大脑与手足、眼睛、皮肤等的关系。ATMEL公司的AT91系列单片机就是一款应用ARM7TDMI核心的优秀单片机。
这款单片机有100个引脚(接口)，包括EBI(external bus interface，连接片外存储)、AIC（连接外部中断）、TC（定时器）、USART、PIO（并行IO引脚）、CLOCK（主时钟输入输出）、WD（Watchdog溢出输出引脚）、Reset、ICE（在线调试引脚，它通过JTAG接口直接与ARM7TDMI的ICE接口相连）、Power（提供VDD、GND引脚）和一些可以由用户自定义的引脚。这些外设通过总线与处理器内核连接，ARM7TDMI通过预定义的寄存器得知外设的状况并通过写寄存器来操控外设。指令池和数据池除了使用内置ROM和SRAM，也可以通过EBI接口使用外部存储空间。
单片机的内部，ARM7TDMI和单片机ICE接口直接连接，ARM7TDMI通过高速的ASB总线管理RAM、ROM、寄存器外设，ASB总线通过AMBA Bridge桥接低速的APB总线，APB总线连接AIC（接收片内外中断信息并直接传给ARM7内核）等一些简单低速外设和PIO controller（将可自定义引脚配置为用户定义的形式）。
9.3 μClinux/uClinux嵌入式操作系统
MMU给予操作系统使用虚拟地址的能力，对地址空间进行更加灵活的管理。但在很多小型的嵌入式系统中，仅凭物理地址即可满足内存管理需求了，出于减少系统复杂程度、降低硬件及开发成本、降低功耗的考虑，遂在处理器的硬件设计中取消了MMU模块。
与之相适应，也产生了经过小型化改造的Linux操作系统――uClinux。uClinux保留了Linux的大多数优点：稳定、可移植性、网络功能、对各种文件系统完备的支持、标准丰富的API。它编译的目标文件不会超过数百KB的数量级，特别适用于少内存或flash的单片机。它采用的文件系统是romfs，比ext文件系统节约空间，但不支持动态擦写保存，对于系统需要动态保护的数据采用虚拟RAM盘的方法处理。
9.4 SkyEye硬件模拟平台
正如RTL设计可以进行Modelsim仿真，uClinux的内核可以在PC上进行软件模拟，SkyEye就是一个这样的模拟平台。SkyEye的目标是在通用的Linux和Windows平台上实现一个纯软件的IDE，模拟运行（指令级模拟）常见的嵌入式计算机系统，对它们和它们的各种系统软件如TCP/IP、图形子系统、文件子系统进行源码级分析调试。
下载并在Linux下安装SkyEye。下载对应AT91系列单片机的uClinux内核的bin代码uclinux0（无扩展名，可执行文件格式）、romfs文件格式的文件系统boot0.rom，放在同一目录下，并在该目录下创建skyeye.conf，指定CPU类型、单片机平台、ROM/RAM/寄存器空间的地址分配、log信息。接下来在终端下进入该目录，执行命令"skyeye -e uclinux0"，即可启动一次uClinux操作系统在SkyEye上的模拟运行，并打印出log信息。
uClinux的启动分为两个阶段，第一个阶段是bootloader启动阶段，第二个阶段是Linux内核的初始化和启动。log信息中，起始行到"Linux version ..."之前的部分是SkyEye的运行信息；该行起至"POSIX conformance testing by UNIFIX"一行止是第一阶段的运行信息，打印了Bootloader的头信息、版本、编译时间，并运行硬件初始化工作；剩下的从"Linux NET4.0 for Linux 2.4"起的部分是第二阶段的运行信息，这一阶段内核初始化，然后打印出uClinux的log标志，并把控制权交给Sash command shell。
9.5 Modelsim下仿真uClinux启动过程
类似SkyEye，我们可以利用兼容ARM7/9的处理器内核，加载uClinux的bin文件，模拟其启动过程。当然，在仿真过程中，需要不断参照SkyEye的运行结果（作为标准输出）调试我们的仿真源码。另外值得一提的是，我们只有处理器内核，但uClinux的运行依赖单片机，它会访问单片机的外设，包括串口、定时器、watchdog、PIO控制器等，虽然我们可以为每个外设写一个行为模型，但本次仿真只模拟其启动过程，所以我们可以简化，对于不经常访问的寄存器直接返回能使uClinux正常启动的期望的返回值，这些数值从SkyEye文档或AR91系列单片机文档中可以得知。
下面来看仿真源码具体如何设计。首先，从https://code.google.com/archive/p/arm-cpu-core/下载仿真文件包，其中包含uclinux0.bin和root文件系统boot0.bin，在testbench中声明两块与文件大小匹配的存储空间（如reg[7:0] boot_all[383999:0]），将这两个文件读入；并且按照SkyEye对ROM/RAM空间的定义（共定义了7块，但仿真只用到4块），初始化4块ROM/RAM空间，其中2块的前一部分加载文件内容，剩余部分和另外2块空间全部初始化为0。
uClinux的数据池和指令池初始化完毕，现在把兼容ARM9处理器内核例化到testbench内、生成100MHz时钟信号、对处理器内核进行初始化，需要注意的是，因为系统按照skyeye.conf中的设定从0x0100_0000开始取第一条指令，因此需要修改处理器内核的源码，设定复位地址为0x0100_0000。
接下来描述指令池和数据池的行为。指令池根据地址高位部分的不同，从4块RAM空间中的前3块送出对应指令。至于数据池，我们把每次对数据池的读写（以字为单位）按字节分为4部分各用一个always语句描述，按照地址可以分为对RAM/ROM的读写和对寄存器的读写，前者与指令池同理实现，对于后者，由于我们只是仿真，因此可以忽略对这些寄存器的写，而对于寄存器的读则直接返回能使uClinux正常启动的期望值。但有一个例外，若需要对串口的控制寄存器进行读写，我们需要将读写的内容在屏幕上完整地展现出来，这样才能得到仿真输出信息；AR91系列单片机通过串口打印的方式是先向指定的寄存器中写入地址，然后向另一指定寄存器中写入字符串的长度，串口会自动从RAM中该地址开始取出给定长度的字符串打印，我们在仿真代码中参照实现即可。
最后我们描述IRQ中断，这是为了模仿TC1定时器的行为，其每计数一定的时间就生成一个IRQ中断（但我们不需要研究TC1的具体触发原理，只需要在uClinux启动过程中应该发出中断的时间点发出中断即可，可以直接用26条#xxxxxxx irq = 1; #10 irq = 0;来实现），这些IRQ中断用于计算BogoMIPS，即语句"Calibrating delay loop... 13.00 BogoMIPS代表的计算过程。
至此我们就完成了testbench的设计。仿真90ms，就可以在Transcript窗口中看到uClinux的启动信息了。

第十章 Linux操作系统仿真――仿真mini2440开发板模型启动带MMU的操作系统
10.1 ARM920T处理器内核
和前面介绍过的ARM7TDMI系列相比，ARM9TDMI采用数据池和指令池访问分开的哈佛结构，性能更佳。ARM9TDMI系列采用五级流水线：取指、译码、执行、访存、回写。ARM9TDMI系列包括三个产品：ARM9TDMI，裸内核；ARM920T，内核+cache+存储器管理单元MMU；ARM940T，ARM9TDMI+cache+保护单元MPU。这里的cache都是每颗CPU两个cache，分别针对数据和指令。
ARM920T以ARM9TDMI为核心。ARM9TDMI带有和ARM7TDMI类似的调试接口、协处理器接口。ARM920T中，指令池和数据池模型由自带cache充当，cache miss时通过AMBA总线访存；如果是写数据池的操作，则由专门的write buffer模块完成回写。服务于指令池和数据池的各有一个MMU，若软件需要控制MMU则通过协处理器CP15来完成。CP15共有15个寄存器，软件若想控制cache或启动MMU，则通过协处理器访问指令MCR或MRC对这15个寄存器进行访问，来达到控制的目的。这15个寄存器包括ID code、cache type、cache & MMU control、TLB operation register等。
cache的具体作用是对数据或指令进行缓存。MMU有两个功能：对数据池或指令池的访问地址进行转换、对访问的权限进行检查。具体而言，为了将虚拟地址转换成物理地址，MMU从内存中找到该地址域对应的转换页，把虚拟地址的高位部分替换得到物理地址；并且从转换页中可以读到该部分地址域的权限信息，结合CPU的状态即可判定这次访问是否合法。
10.2 S3C2440A 32位微控制器
S3C2440A微控制器是以ARM920T处理器为核心的一种单片机，采用130nm CMOS标准工艺制造。三星为其配备了大量外设接口，充分发挥ARM920T强大的处理能力。
S3C2440A通过两条总线连接外设，高速的AHB总线和低速的APB总线，后者连接对速度要求不高的外设，并通过AMBA Bridge和AHB总线相连接。外设的种类有：外部Memory控制器、LCD控制器、DMA控制器、UART串口、定时器、实时时钟、通用I/O端口、外部中断源等。这些外设通过总线连接并将控制权交给处理器内核。
10.3 mini2440 ARM9开发板
S3C2440A只是一颗芯片，不能独立工作，为了发挥它的高性能，必须在一块PCB板上为其各个外设接口连接上相应的外设。mini2440 ARM9开发板就是这样的设备，连接了LCD显示、100M以太网RJ-45接口、串口、USB host、USB slave B型接口等。mini2440 ARM9开发板的“大脑”是三星S3C2440微控制器，主频400MHz，最高可达533MHz；SDRAM大小64MB、工作频率可以高达100MHz，数据总线宽度32位；我们烧录的嵌入式程序主要放在Flash存储中，板上有两种Flash存储，256MB的NAND Flash和2MB的NOR Flash。它们提供了处理器工作的数据池和指令池模型，是使得微控制器可以工作的最低需求。
为了理解mini2440的运行原理，我们按照对处理器运行模型划分的3大部分ROM、RAM和寄存器的顺序阐述。模型中的ROM对应着开发板上的NOR Flash或NAND Flash，两者都可以用于启动整个开发板；不同之处在于NOR Flash的每一字节都有地址编号，可以直接在AMBA总线上发出地址来访存，因此可以直接用于启动开发板。NAND Flash存储的数据在总线上没有规定的地址信息，访问它必须通过对一个寄存器写入读写操作，然后写入相对地址信息，才能从另一个寄存器中读出该地址对应的数据；它不能从AMBA总线直接访问，也就无法直接从NAND Flash中取出指令，所以不能直接用于启动开发板；当然本开发板上的NAND Flash进行了改造，包含一个4KB的boot SRAM，默认编址下它位于最高地址处，若需要将NAND Flash用于启动，则将其编址到0x0，这4KB的SRAM存放boot loader，它将NAND Flash存放的Linux内核复制到SDRAM内，然后跳转到SDRAM开始执行。
模型中的RAM是由64MB的SDRAM来充当的，其每个字节数据都有对应地址。模型中的寄存器则较为复杂，mini2440的外设很多、且每个外设都有固定的寄存器和行为规则，嵌入式工程师需要查阅用户手册并按这个规定编写程序，当然在开发mini2440开发板时也需要按S3C2440A的引脚分布图把各引脚链接到相应的外设。
10.4 NAND Flash仿真模型
mini2440开发板上，Linux内核及系统文件都是存放在256MB NAND Flash内，因此需建立一个NAND Flash的仿真模型，装入mini2440开发板中导出的image，按照输入的访问地址将image对应位置的数据送给处理器内核。
S3C2440A微控制器通过读写寄存器的方式来获取NAND Flash的内容。读NAND Flash的过程：对控制寄存器发出读操作，对地址寄存器写入读地址，轮询读取状态寄存器，若读取状态寄存器回答成功，则从读数据寄存器取得该地址数据。写NAND Flash过程类似。
设计此仿真模型，首先定义它的RTL输入输出端口，然后利用initial语句对image进行装入，最后只需非常简单的两条assign语句（按分区计算真实地址、读数据）即可完成按地址读数据的操作。
10.5 为兼容ARM9处理器内核增加协处理器指令
在ARM920T中，为了实现对MMU和cache的管理，处理器会不断对协处理器CP15的各个寄存器进行读写。为了能够进行仿真，必须为兼容ARM9处理器内核增加协处理器指令的支持。协处理器指令分为两类：MRC，将处理器内部寄存器组(R0-R15)的某个寄存器送入协处理器的寄存器；MCR，将协处理器的某个寄存器送入寄存器组。因为仿真中实际并不存在协处理器CP15，所以我们忽略所有MRC指令，只实现MCR指令。
首先，我们参照MCR指令的格式在处理器内核中添加code_is_mcr和cmd_is_mcr；然后，修改all_code的表达式，向其中添加MCR指令；增加一个输出端口output logic inst_mcr，表示MCR指令即将进入第三级流水线、需要协处理器在下一时钟周期给出寄存器值作为应答；增加一个输入端口input logic[31:0] mcr_data，用于输入MCR的寄存器值；修改to_vld、to_num、to_data，使得cmd_is_mcr生效时，亦即MCR位指令在第三级时mcr_data能够进入对应的寄存器。
10.6 仿真启动Linux操作系统
首先在testbench文件中例化ARM9内核和NAND Flash模型，其中NAND Flash的设计文件中需要通过initial语句装入mini2440的NAND Flash镜像(bin文件)。
梳理Linux操作系统在mini2440上的启动过程，可以分成3大步骤：首先，NAND Flash的前4KB作为bootloader执行，一些初始化工作结束后，它把NAND Flash内存放的Linux内核拷贝入SDRAM内；bootloader结束后，跳转入SDRAM内执行，64MB SDRAM同时充当ROM和RAM，此时处理器内核发出的地址是物理地址，可以直接从SDRAM内读指令或数据，直至处理器写协处理器寄存器，启动MMU功能；MMU启动后，程序依然在SDRAM内执行，地址必须进行转换，只不过转换后的物理地址依然指向SDRAM。
由此可见，SDRAM是程序执行的主战场。所以我们接下来对SDRAM进行模拟：声明一个64MB的reg数组sdram，初值为0。仿真的时候不需要实现cache，对于给出的地址addr直接返回sdram[addr]即可。
然后模拟bootloader，声明reg[7:0] rom[4095:0]，用读入的NAND Flash映像的前4KB初始化。然后就可以写出指令池模型，第一个阶段返回rom中对应地址的内容，后两个阶段返回sdram中的内容，若不属于合法地址则报错显示"rom physical address overrun"。访问sdram时的地址应该用rom_addrm（MMU转换后的物理地址）而非rom_addr，因为第三阶段是启用MMU的。
接下来模拟MMU。定义使能信号mmu_enable = 1'b0，用一个always语句描述其更改：如果CPU内核执行MRC指令对CP15的Register 1: Control的bit[0]位写入数值，就将这个数值赋给mmu_enable。虚拟地址向物理地址的转换通过页表实现，页表的首地址存放在CP15的Register 2: translation table base(TTB) register中（用一个always语句描述处理器内核对该寄存器的写入），有了TTB和虚拟地址ram_addr即可查找相应的页表项，对应页表项的地址为{ttb, ram_addr[31:20], 2'b0}（每1MB虚拟地址空间共用一个页表项），然后再根据得到的页表项的低两位判断查表情况，每种情况对应的页表项都有不同的结构，低两位为11时得到直接转换的物理地址{entry_data[31:20], ram_addr[19:0]}，为00时发出数据访问异常中断，置位ram_abort=1，其他两种情况需查二级页表，二级页表查表过程类似。rom_addr到rom_addrm也要经过这种转换。
上面我们完成了启动的3大步骤的设计，最后我们还需要模拟外设。因为这个镜像是从mini2440开发板中直接复制出来的，所以启动时会检查、初始化板上的各种外设。对每种外设进行行为级模拟代价太高，考虑到我们只需要模拟boot过程，所以除了串口以外，我们可以虚拟所有外设，对外设的写操作我们忽略，对外设的读操作我们直接返回能使Linux正常启动的期望的返回值，这些数值取决于mini2440开发板。具体来说，只需要在设计ram_rdata时，若ram_addrm指向了外设寄存器的地址，就给ram_rdata赋以这些故意设计的返回值。当然也会有少数例外，例如读取定时器的技术状态时应回答真实的值。还需实现串口的打印，若对串口寄存器写入了值，我们就直接将其按字符打印到屏幕上($write)。
至此我们就完成了testbench的设计。执行命令"run -all"，就可以在Transcript窗口中看到Linux的启动信息了。完整的启动过程大约需要仿真7~8s才完成。在仿真的最后阶段，可能由于某些寄存器的设定不到位，会有略微不同，书上的仿真结果仅供参考。
